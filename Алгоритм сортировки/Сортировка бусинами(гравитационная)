def bead_sort(arr):
    """
    Реализация алгоритма сортировки бусинами (Bead Sort / Гравитационная сортировка).

    Особенности:
    - Работает только с неотрицательными целыми числами.
    - Требует создания дополнительной 2D-сетки, что может потреблять много памяти,
      если максимальное значение в массиве очень велико.

    Args:
        arr: Список неотрицательных целых чисел для сортировки.

    Returns:
        Отсортированный список чисел.
    
    Raises:
        ValueError: Если входной массив содержит отрицательные числа или не целые числа.
    """
    if not arr:
        return []

    # Проверка на соответствие требованиям алгоритма (неотрицательные целые числа)
    for x in arr:
        if not isinstance(x, int) or x < 0:
            raise ValueError("Сортировка бусинами работает только с неотрицательными целыми числами.")

    # Шаг 1: Находим максимальное значение в массиве
    # Это определяет "ширину" нашего абака (количество стержней/столбцов)
    max_val = max(arr) if arr else 0 # Если массив пустой, max_val = 0

    # Если максимальное значение 0, то все числа 0, уже отсортировано
    if max_val == 0:
        return arr[:] # Возвращаем копию, чтобы избежать изменения исходного массива

    num_elements = len(arr)

    # Шаг 2: Инициализируем 2D-сетку (матрицу) "бусин"
    # Размер: num_elements строк x max_val столбцов
    # grid[r][c] == 1 означает, что на позиции (r, c) есть бусина
    # Изначально заполняем бусины в каждой строке в соответствии с исходным числом.
    # Пример: arr[0] = 3 -> grid[0] = [1, 1, 1, 0, 0] (если max_val=5)
    
    # Создаем пустую сетку
    beads_grid = [[0 for _ in range(max_val)] for _ in range(num_elements)]

    # Заполняем сетку бусинами
    for r in range(num_elements):
        for c in range(arr[r]):
            beads_grid[r][c] = 1

    # Шаг 3: Симулируем "гравитацию"
    # Проходим по каждому столбцу (стержню)
    for c in range(max_val):
        bead_count = 0
        # Считаем количество бусин в текущем столбце
        for r in range(num_elements):
            if beads_grid[r][c] == 1:
                bead_count += 1
        
        # Переставляем бусины в этом столбце так, чтобы они "упали" вниз
        # Сначала очищаем весь столбец
        for r in range(num_elements):
            beads_grid[r][c] = 0
        
        # Затем размещаем counted_beads бусин в нижней части столбца
        # (т.е. сдвигаем их к большим индексам строк)
        for r in range(num_elements - 1, num_elements - bead_count - 1, -1):
            beads_grid[r][c] = 1

    # Шаг 4: Считываем отсортированный массив
    # Количество бусин в каждой строке после гравитации соответствует отсортированному значению
    sorted_arr = []
    for r in range(num_elements):
        current_value = 0
        for c in range(max_val):
            if beads_grid[r][c] == 1:
                current_value += 1
        sorted_arr.append(current_value)

    return sorted_arr

# --- Примеры использования ---
if __name__ == "__main__":
    data1 = [29, 25, 3, 49, 9, 37, 21, 43]
    print(f"Исходный массив 1: {data1}")
    sorted_data1 = bead_sort(data1)
    print(f"Отсортированный массив 1: {sorted_data1}") # Ожидаем [3, 9, 21, 25, 29, 37, 43, 49]

    data2 = [5, 4, 3, 2, 1]
    print(f"\nИсходный массив 2: {data2}")
    sorted_data2 = bead_sort(data2)
    print(f"Отсортированный массив 2: {sorted_data2}") # Ожидаем [1, 2, 3, 4, 5]

    data3 = [1, 2, 3, 4, 5]
    print(f"\nИсходный массив 3 (уже отсортирован): {data3}")
    sorted_data3 = bead_sort(data3)
    print(f"Отсортированный массив 3: {sorted_data3}") # Ожидаем [1, 2, 3, 4, 5]

    data4 = [7]
    print(f"\nИсходный массив 4 (один элемент): {data4}")
    sorted_data4 = bead_sort(data4)
    print(f"Отсортированный массив 4: {sorted_data4}") # Ожидаем [7]

    data5 = []
    print(f"\nИсходный массив 5 (пустой): {data5}")
    sorted_data5 = bead_sort(data5)
    print(f"Отсортированный массив 5: {sorted_data5}") # Ожидаем []

    data6 = [0, 0, 0]
    print(f"\nИсходный массив 6 (только нули): {data6}")
    sorted_data6 = bead_sort(data6)
    print(f"Отсортированный массив 6: {sorted_data6}") # Ожидаем [0, 0, 0]

    data7 = [1, 5, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1]
    print(f"\nИсходный массив 7: {data7}")
    sorted_data7 = bead_sort(data7)
    print(f"Отсортированный массив 7: {sorted_data7}")

    # Пример, который вызовет ошибку из-за отрицательного числа
    try:
        data_error = [10, -5, 20]
        print(f"\nПопытка сортировки массива с отрицательным числом: {data_error}")
        bead_sort(data_error)
    except ValueError as e:
        print(f"Ошибка: {e}")

    # Пример, который вызовет ошибку из-за нецелого числа
    try:
        data_error_float = [1, 2.5, 3]
        print(f"\nПопытка сортировки массива с нецелым числом: {data_error_float}")
        bead_sort(data_error_float)
    except ValueError as e:
        print(f"Ошибка: {e}")
