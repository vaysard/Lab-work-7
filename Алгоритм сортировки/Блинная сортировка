def _flip(arr, k):
    """
    Вспомогательная функция, которая переворачивает префикс массива arr
    от начала (индекс 0) до индекса k включительно.
    """
    start = 0
    while start < k:
        arr[start], arr[k] = arr[k], arr[start]
        start += 1
        k -= 1

def _find_max_index(arr, n):
    """
    Вспомогательная функция, которая находит индекс максимального элемента
    в подмассиве arr[0...n-1].
    """
    max_val = arr[0]
    max_idx = 0
    for i in range(1, n):
        if arr[i] > max_val:
            max_val = arr[i]
            max_idx = i
    return max_idx

def pancake_sort(arr):
    """
    Реализация алгоритма Блинной сортировки (Pancake Sort).

    Принцип работы:
    1. Найти максимальный элемент в неотсортированной части массива.
    2. Перевернуть подмассив от начала до позиции максимального элемента,
       чтобы этот элемент оказался первым.
    3. Перевернуть весь текущий неотсортированный подмассив, чтобы
       максимальный элемент оказался в конце (на своей окончательной позиции).
    4. Повторять процесс для оставшейся неотсортированной части массива.

    Сложность: O(n^2) в худшем и среднем случае.
    """
    n = len(arr)

    # Итерируемся от размера всего массива вниз до 1
    # current_size представляет размер неотсортированной части массива
    # (от 0 до current_size - 1)
    for current_size in range(n, 1, -1):
        # Шаг 1: Найти индекс максимального элемента
        # в текущей неотсортированной части (arr[0...current_size-1])
        max_idx = _find_max_index(arr, current_size)

        # Если максимальный элемент уже находится на своей конечной позиции
        # (в конце текущей неотсортированной части), то ничего не делаем.
        if max_idx == current_size - 1:
            continue

        # Шаг 2: Если максимальный элемент не в начале,
        # переворачиваем подмассив от начала до max_idx,
        # чтобы он оказался в arr[0].
        if max_idx != 0:
            _flip(arr, max_idx)

        # Шаг 3: Переворачиваем весь текущий неотсортированный подмассив
        # (от arr[0] до arr[current_size-1]), чтобы максимальный элемент
        # (который теперь в arr[0]) переместился в конец этого подмассива.
        _flip(arr, current_size - 1)
    
    return arr

# --- Примеры использования ---
if __name__ == "__main__":
    data1 = [29, 25, 3, 49, 9, 37, 21, 43]
    print(f"Исходный массив 1: {data1}")
    pancake_sort(data1)
    print(f"Отсортированный массив 1: {data1}") # Ожидаем [3, 9, 21, 25, 29, 37, 43, 49]

    data2 = [5, 4, 3, 2, 1]
    print(f"\nИсходный массив 2: {data2}")
    pancake_sort(data2)
    print(f"Отсортированный массив 2: {data2}") # Ожидаем [1, 2, 3, 4, 5]

    data3 = [1, 2, 3, 4, 5]
    print(f"\nИсходный массив 3 (уже отсортирован): {data3}")
    pancake_sort(data3)
    print(f"Отсортированный массив 3: {data3}") # Ожидаем [1, 2, 3, 4, 5]

    data4 = [7]
    print(f"\nИсходный массив 4 (один элемент): {data4}")
    pancake_sort(data4)
    print(f"Отсортированный массив 4: {data4}") # Ожидаем [7]

    data5 = []
    print(f"\nИсходный массив 5 (пустой): {data5}")
    pancake_sort(data5)
    print(f"Отсортированный массив 5: {data5}") # Ожидаем []

    data6 = [1, 5, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1]
    print(f"\nИсходный массив 6: {data6}")
    pancake_sort(data6)
    print(f"Отсортированный массив 6: {data6}")
